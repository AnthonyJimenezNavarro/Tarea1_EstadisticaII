---
title: "Tarea1_C24067"
output: html_document
date: "2024-09-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Ejercicio 2

## 1

```{r}
hist(base_salarios$Coutas, main = "Histograma de la Cuotas", freq = F, xlab = "Cuotas", ylab = "Densidad")
lines(density(base_salarios$Coutas), col = "aquamarine4", lwd = 2)
```

## 2

### Biweight

```{r}
plot(density(base_salarios$Coutas, bw = "nrd0",  kernel = "biweight"), col = "aquamarine4", lwd = 2, main = "Densidad de las Cuotas según kernel Bandwidth de Silverman", xlab = "Cuotas", ylab = "Densidad")
```


Respecto al "nrd0", fue tomado de: https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/bandwidth

### Gaussiana

```{r}
plot(density(base_salarios$Coutas, kernel = "gaussian"), col = "aquamarine4", lwd = 2, main = "Densidad de las Cuotas según kernel Gaussiano", xlab = "Cuotas", ylab = "Densidad")
```

### Epanechnikov
```{r}
plot(density(base_salarios$Coutas, kernel = "epanechnikov"), col = "aquamarine4", lwd = 2, main = "Densidad de las Cuotas según kernel Epanechnikov", xlab = "Cuotas", ylab = "Densidad")
```

### Coseno
```{r}
plot(density(base_salarios$Coutas, kernel = "cosine"), col = "aquamarine4", lwd = 2, main = "Densidad de las Cuotas según kernel Coseno", xlab = "Cuotas", ylab = "Densidad")
```

### Uniforme
```{r}
plot(density(base_salarios$Coutas, kernel = "rectangular"), col = "aquamarine4", lwd = 2, main = "Densidad de las Cuotas según kernel Rectangular", xlab = "Cuotas", ylab = "Densidad")
```

### Triangular
```{r}
plot(density(base_salarios$Coutas, kernel = "triangular"), col = "aquamarine4", lwd = 2, main = "Densidad de las Cuotas según kernel Triangular", xlab = "Cuotas", ylab = "Densidad")
```

## 3

```{r}
(kernels <- eval(formals(density.default)$kernel))
```

```{r}
plot(density(base_salarios$Coutas, kernel = "gaussian"), col = "black", lwd = 2, main = "Densidad de las Cuotas según kernel", xlab = "Cuotas", ylab = "Densidad")
for(i in 2:length(kernels))
lines(density(base_salarios$Coutas, kernel = kernels[i]), col = i, lwd = 2)
legend("topright", legend = kernels, col = seq(kernels), lty = 1,lwd = 2,cex = 0.5)
```

# Ejercicio 3

## 1

El Criterio de Información de Akaike (AIC) evalúa la calidad de un modelo ajustado considerando tanto la cantidad de parámetros como la calidad del ajuste. La fórmula del AIC es:

AIC = 2K - 2ln(L)

Donde k representa el número de parámetros del modelo y L es la función de máxima verosimilitud del modelo. El AIC penaliza los modelos más complejos, es decir, aquellos con más parámetros, para reducir el riesgo de sobreajuste. Se considera que el mejor modelo es aquel con el valor de AIC más bajo.

## 2

```{r}
library(univariateML)
library(rriskDistributions)
library("fGarch")
```

```{r}
base_salarios <- read.csv("BaseSalarios.csv", header = TRUE, sep = ";", stringsAsFactors = FALSE)
base_salarios <- base_salarios[ , !(names(base_salarios) %in% c("X"))]
sum(is.na(base_salarios$Coutas))
```

```{r}
base_salarios <- read.csv("C:/Users/antho/OneDrive/Escritorio/Estadistica/Tarea1_EstadisticaII/BaseSalarios.csv", header = TRUE, sep = ";", stringsAsFactors = FALSE)
base_salarios <- base_salarios[, !names(base_salarios) %in% "X"]
base_salarios <- na.omit(base_salarios)
```

```{r}
valores <- model_select(base_salarios$Coutas)
print(valores)
mean_model <- as.numeric(valores["mean"])
sd_model <- as.numeric(valores["sd"])
nu_model <- as.numeric(valores["nu"])
xi_model <- as.numeric(valores["xi"])

L <- sum(dsged(base_salarios$Coutas, mean = mean_model, sd = sd_model, nu = nu_model, xi = xi_model, log = TRUE))
k <- 4
AIC_1 <- -2 * L + 2 * k

exp <- mlexp(base_salarios$Coutas)
gamma <- mlgamma(base_salarios$Coutas)
lognormal <- mllnorm(base_salarios$Coutas)
weibull <- mlweibull(base_salarios$Coutas)
loggamma <- mllgamma(base_salarios$Coutas+1)
uniform <- mlunif(base_salarios$Coutas)

AIC_Calculados <- data.frame(
  DistribuCION = c("Model_Select", "Exponential", "Gamma", "Lognormal", "Weibull", "Loggamma", "Uniform"),
  AIC = c(AIC_1, 
          AIC(exp), 
          AIC(gamma), 
          AIC(lognormal),
          AIC(weibull), 
          AIC(loggamma), 
          AIC(uniform))
)

print(AIC_Calculados)
```

De la tabla se logra observar que el menor valor de AIC corresponde a la distribución Weibull, de forma que siguiendo el Criterio de Información de Akaike es elije este.

## 3

```{r}
ajuste_risk <- fit.cont(base_salarios$Coutas)
print(ajuste_risk)
```

## 4

Del punto 2 se observa que la distribución que mejor se ajuste corresponde a Weibull, pero del punto 3, al utilizar fit.cont(), podemos observar que la distribución Gompertz, presenta un valor de AIC menor al resto, de forma que resulta la más adecuada, pero ya que esta no formaba parte del inciso, se decide tomar la segunda mejor que corresponde a Weibull.

## 5

```{r}
bootstrap <- bootstrapml(weibull, reps = 1000, map = function(x) c(mean = mean(x), sd = sd(x)))

IC_mean <- c(bootstrap[1,1], bootstrap[1,2])
IC_sd <- c(bootstrap[2,1], bootstrap[2,2])

print(IC_mean)
print(IC_sd)
```



